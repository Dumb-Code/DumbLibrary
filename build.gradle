import org.apache.commons.io.FileUtils

import java.nio.file.Files

buildscript {
    repositories {
        jcenter()
        maven { url = "http://files.minecraftforge.net/maven" }
        maven { url = "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
        classpath "gradle.plugin.com.matthewprenger:CurseGradle:1.1.0"
		classpath "net.dumbcode.gradlehook:GradleHook:1.2.0"
    }
}

apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: "maven-publish"
apply plugin: "com.matthewprenger.cursegradle"
apply plugin: "net.dumbcode.gradlehook"

//Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.

import groovy.json.JsonSlurper
import com.matthewprenger.cursegradle.CurseArtifact
import net.dumbcode.gradlehook.tasks.form.FieldObject
import net.dumbcode.gradlehook.tasks.form.PostForm
import java.time.Instant
import java.time.ZoneOffset;

def mod_version = getVersion()
def curseforgeID = "298694"
version = "1.12.2-" + mod_version
group = "com.dumbcode.dumblibrary" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = "dumblibrary"

sourceCompatibility = targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.
compileJava {
    sourceCompatibility = targetCompatibility = '1.8'
}

minecraft {
    version = "1.12.2-14.23.4.2705"
    runDir = "run"
    mappings = "stable_39"
}

repositories {
    mavenCentral()
    maven {
        url = "https://maven.mcmoddev.com"
    }
    maven {
        url = "http://dvs1.progwml6.com/files/maven"
    }
    maven {
        name = "CurseForge"
        url = "https://minecraft.curseforge.com/api/maven/"
    }
}

dependencies {
    deobfCompile "mezz.jei:jei_1.12.2:4.9.1.187:api"
    runtime "mezz.jei:jei_1.12.2:4.9.1.187"
    compile "net.ilexiconn:llibrary:1.7.14-1.12.2"
    compile 'org.projectlombok:lombok:1.18.0'
    compile group: 'org.apache.commons', name: 'commons-collections4', version: '4.0'
}

def run(String command, boolean print = false, File f = file("Changelogs")) {
    def commands = command.split(" ")
    def outCommands = new String[commands.length]

    for (int i = 0; i < commands.length; i++) {
        outCommands[i] = commands[i].replace("~", " ")
    }

    def out = Runtime.getRuntime().exec(outCommands, null, f).text.trim()
    if(print) {
        println out
    }
}

task("publishMod", group: "upload", description: "Publish the mod to curseforge and the webhook", dependsOn: tasks.getByName("curseforge")) {


    doFirst {
        def changelog = "https://raw.githubusercontent.com/Dumb-Code/Changelogs/master/dumb_library.txt".toURL().text
        println "-----------------------------"
        println "----------Changelog----------"
        println "-----------------------------"
        println changelog
        println "-----------------------------"

        def cftask = tasks.getByName("curseforge$curseforgeID")
        //Manually set the changelog, as the changelog in the extension may be cached wrong.
        (cftask.property("mainArtifact") as CurseArtifact).changelog = changelog
        (cftask.property("additionalArtifacts") as List<CurseArtifact>).forEach {artifact -> artifact.changelog = changelog}
    }

    doLast {
        //This is kind of a hack, I am aware. However, cursegradle doesnt store their IDs anywhere, apart from parent IDs on additional artifacts.
        //Maybe we could ask CurseGradle to store their Ids in the artifact class.
        List<CurseArtifact> artifacts = tasks.getByName("curseforge$curseforgeID").property("additionalArtifacts") as List<CurseArtifact>
        if (artifacts.isEmpty()) {
            println "Error, unable to access artifact parent ID. Need to have additional artifacts for this to work"
        }
        def id = artifacts.get(0).parentFileID

        println "Artifact uploaded with id $id"

        def url = "https://minecraft.curseforge.com/projects/dumb-library/files/$id"
        def color = 0x686868
        def datetime = Instant.now().atZone(ZoneOffset.UTC).toString()
        def form = new PostForm(dumblibrary_publish_url) //In the ~/.gradle/gradle.properties file
        form.addObject new FieldObject('payload_json', "{ \"embeds\": [{ \"title\": \"New Version $project.version !\", \"color\": $color, \"url\": \"$url\" , \"timestamp\": \"$datetime\"}]}")
        def result = form.send()

        println "Webhook uploaded with response code $result.responseCode"

        //Setup
        run "git clone https://github.com/Dumb-Code/Changelogs.git", false, file(".")
        run "git remote rm origin"
        run "git remote add origin https://Travis-CI:${github_token}@github.com/Dumb-Code/Changelogs.git"

        //Config
        run "git config --global commit.gpgsign false"

        println "Successfully cloned and setup git"

        //Delete
        file("Changelogs/dumb_library.txt").delete()

        println "Reset changelog file"

        //Push
        run "git add dumb_library.txt"
        run "git commit --message \"Deleted~dumb_library.txt~for~new~build\"", true //Maybe add version number?
        run "git push origin master"

        println "Pushed changes to master"

        //Delete the folder
        FileUtils.deleteDirectory(file("Changelogs"))

        println "Cache folder deleted"
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = "sources"
    from sourceSets.main.allSource
}

task devJar(type: Jar) {
    classifier = "dev"
    from sourceSets.main.output
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = "javadoc"
    from javadoc.getDestinationDir()
}

artifacts {
    archives sourcesJar
    archives devJar
    archives javadocJar
}

curseforge {
    apiKey = project.hasProperty("curseforge_api_key") ? curseforge_api_key : "###"//In the ~/.gradle/gradle.properties file
    project {
        id = curseforgeID
        releaseType = 'beta'
        relations {
            requiredLibrary 'llibrary'
        }
        mainArtifact jar
        addArtifact sourcesJar
        addArtifact devJar
        addArtifact javadocJar
    }
}

String getVersion() {
    def major = "0"
    def revision = "0"
    def patch = "0"
    def prefix = "public static final String VERSION = \""
    def file = file("src/main/java/net/dumbcode/dumblibrary/DumbLibrary.java")
    file.eachLine { String s ->
        s = s.trim()
        if (s.startsWith(prefix)) {
            s = s.substring(prefix.length(), s.length() - 2)
            def pts = s.split("\\.")
            major = pts[0]
            revision = pts[1]
            patch = pts[2]
        }
    }

    return "$major.$revision.$patch";
}

processResources {
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'

        // replace version and mcversion
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

gradlehook {
    urlToken System.getenv('WEBHOOK_URL')
    
    addField 'payload_json', '{ "embeds": [{ "timestamp": "{{datetime}}" }] }'
    
    addArtifact jar
    addArtifact sourcesJar
    addArtifact devJar
    addArtifact javadocJar
}
